---
Project:
  - UVM
description:
tags:
  - UVM
created: 2025-08-11 | 10:15
parent: Resource
---
# 001-Video

> “通常来说,DUT中会有一组控制端口,通过控制端口,可以配置DUT中的寄存器”

“考虑如下一个问题,在上节所示的DUT中,invert寄存器用于控制DUT是否将输入的激励按位取反。在取反的情况下,参考 模型需要读取此寄存器的值,如果为1,那么其输出transaction也需要进行反转。可是如何在参考模型中读取一个寄存器的值呢?”

“uvm_reg_field:这是寄存器模型中的最小单位”

### 寄存器模型
#### UVM REG
- build：这个build与uvm_component的build_phase并不一样,它不会自动执行,而需要手工 调用
	- 所有的reg_filed 都在这里实例化，并进行配置（configure）
	- configure参数
		- 此域的父类
		- 此域的宽度
		- 此域的最低位在整个寄存器中的位置
		- [[寄存器模型#存取方式]]
- new函数
	- 参数:
		- name 
		- size:“这个数字一般 与系统总线的宽度一致”

#### UVM REG BLOCK
1. 创建regmap
2. 实例化invert并配置
3. 调用build 方法
4. 将寄存器加入到default中
“每一个由uvm_reg_block派生的类也要定义一个build函数,一般在此函数中实现所有寄存器的实例 化”
- reg_map: “一个uvm_reg_block中一定要对应一个uvm_reg_map,系统已经有一个声明好的default_map,只需要在build中将其实例化”, 
- 通过调用create_map来实例化
- 参数
	- 名字
	- 参数基地址
	- 系统总线宽度（byte)
	- 大小端
	- 是否按照byte


|               |                                                                                          |
| ------------- | ---------------------------------------------------------------------------------------- |
| uvm_reg_filed | 是最小的单位,是具体存储寄存器数值的变量,可以直接用这个类                                                            |
| uvm_reg       | 是一个“空壳子”,或者用专业名词来说,它是一个纯虚类,因此是不能直接使用的,必须由其派生一个新  类,在这个新类中至少加入一个uvm_reg_field,然后这个新类才可以使用 |
| uvm_reg_block | 用于组织大量uvm_reg的一个大容 器                                                                     |

#### 存取方式
- 共有25中
