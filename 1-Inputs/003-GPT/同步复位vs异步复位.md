---
Project:
  - UVM
description:
tags:
  - UVM
created: 2025-08-12 | 17:18
parent: Resource
---
# 003-GPT
### **一、同步复位（Synchronous Reset）**
#### **1. 定义**

复位信号仅在**时钟有效边沿**（如上升沿）被采样，与时钟同步生效。
```verilog

always @(posedge clk) begin
    if (!rst_sync) begin  // 同步复位条件
        q <= 1'b0;       // 复位动作
    end else begin
        q <= d;          // 正常工作
    end
end

```


#### **2. 核心特点**

|**优点**|**缺点**|
|---|---|
|避免亚稳态（复位释放无需同步）|复位生效延迟（需等待时钟沿）|
|与STA（静态时序分析）流程兼容|占用更多逻辑资源（复位信号参与综合）|
|复位路径可被时序约束（`set_false_path`）|高频时钟下复位脉冲可能被漏采|

#### **3. 应用场景**

- 高频设计（>500MHz）
    
- FPGA逻辑（Xilinx/Intel FPGA推荐同步复位）
    
- 复位信号本身由其他时钟域生成时
    

---

### **二、异步复位（Asynchronous Reset）**

#### **1. 定义**

复位信号**立即生效**，无需等待时钟沿（可视为优先级最高的异步控制）。

```verilog

always @(posedge clk or negedge rst_async) begin
    if (!rst_async) begin  // 异步复位条件
        q <= 1'b0;        // 复位动作
    end else begin
        q <= d;           // 正常工作
    end
end


```

#### **2. 核心特点**

|**优点**|**缺点**|
|---|---|
|复位立即生效（0延迟）|复位释放时可能引发亚稳态|
|节省逻辑资源（直接控制触发器异步端）|对复位信号毛刺敏感|
|保证系统快速进入已知状态|需额外处理复位释放同步问题|

#### **3. 应用场景**
- 上电复位（Power-On Reset）
- 低功耗设计（快速关闭模块）
- 安全关键系统（如汽车电子需紧急复位）

---

### **三、复位解断言时序（Reset De-assertion Timing）**

#### **1. 核心问题：异步复位释放的亚稳态风险**

当异步复位信号（`rst_async`）在**时钟有效沿附近释放**时，部分触发器可能因Tsu/Th违例进入亚稳态 → 导致系统状态不一致。

Diagram

Code

#### **2. 工业级解决方案：复位同步器**

异步断言（Assert），**同步释放**（Synchronous De-assert）

verilog

// 复位同步器模块
module reset_sync (
    input  wire clk,
    input  wire rst_async,    // 异步复位输入
    output wire rst_sync      // 同步复位输出
);
    reg rst_stage1, rst_stage2;

    always @(posedge clk or negedge rst_async) begin
        if (!rst_async) begin          // 异步断言（立即生效）
            rst_stage1 <= 1'b0;
            rst_stage2 <= 1'b0;
        end else begin                 // 同步释放（两级触发器）
            rst_stage1 <= 1'b1;
            rst_stage2 <= rst_stage1;  // 关键：同步释放点
        end
    end

    assign rst_sync = rst_stage2;      // 同步后的复位信号
endmodule

#### **3. 时序波形解析**

plaintext

         __________               __________
clk     /          \_____________/          \
                _______________ 
rst_async ______/               \____________
                    _______   _______ 
rst_stage1 _________/       \_/       \_______
                          _______ 
rst_stage2 _______________/       \___________
                          ↑  
              复位释放在此处同步到clk域（无亚稳态）

#### **4. 设计关键点**

- **两级触发器**：将亚稳态MTBF提升至系统寿命以上
    
- **Gray码精神**：复位信号是单比特 → 同步释放等效于电平同步
    
- **复位树平衡**：全局复位信号需像时钟树一样做平衡布线
    

---

### **四、面试终极灵魂问题**

#### **问题1：同步复位和异步复位如何选择？**

> **答**：
> 
> - **优先异步复位**：对复位延迟敏感的场景（如安全系统），但必须加复位同步器。
>     
> - **改用同步复位**：高频设计（>500MHz）或复位信号跨时钟域时。
>     
> - **混合方案**：
>     
>     verilog
>     

> - always @(posedge clk or negedge rst_async) begin
>         if (!rst_async) q <= 0;       // 异步复位保证速度
>         else if (rst_sync) q <= 0;    // 同步复位用于功能清除
>         else q <= d;
>     end
>     

#### **问题2：为什么复位同步器能消除亚稳态？**

> **答**：  
> 异步复位释放时：
> 
> 1. 第一级触发器（`rst_stage1`）可能进入亚稳态
>     
> 2. 第二级触发器（`rst_stage2`）采样时，第一级已大概率稳定 → 输出无亚稳态
>     
> 3. 两级触发器使MTBF满足：`MTBF > 产品寿命 × 10^3`（如汽车电子要求10^9小时）
>     

#### **问题3：复位同步器的`rst_stage2`输出还有毛刺风险吗？**

> **答**：  
> 无风险！因为：
> 
> - 输入`rst_stage1`是寄存器输出（无毛刺）
>     
> - 输出`rst_stage2`仅在每个时钟沿变化一次 → 绝对干净
>     

---

### **五、验证工程师的特别关注点**

#### **1. 复位验证场景**

|**测试类型**|**验证方法**|Python验证思路|
|---|---|---|
|异步复位有效性|复位期间强制随机数据 → 复位后检查寄存器归零|`dut.reset = 1; dut.data=rand();`|
|复位释放同步|在时钟沿附近释放复位 → 监测亚稳态传播|注入复位释放时间抖动（±Tsu）|
|复位毛刺免疫|生成复位毛刺（<1个周期） → 检查功能|`dut.reset = [1,0,1,0]` 快速切换|

#### **2. 覆盖率指标**

- **复位断言覆盖率**：
    
    systemverilog
    

- // 检查复位释放后状态机是否进入IDLE
    assert property (@(posedge clk) 
        $rose(rst_sync) |=> (state == IDLE);
    
- **复位触发覆盖率**：  
    覆盖所有复位来源（上电复位、看门狗复位、软件复位）
    

#### **3. 实际案例**

> **面试话术**：  
> *“在XX芯片验证中，我通过Python注入异步复位释放时序违例（故意在clk上升沿+0.1ns释放复位），发现了一个状态机启动错误。根本原因是设计者忘记使用复位同步器！”*

掌握复位机制，证明你具备**芯片可靠性的底层掌控力**——这是区分普通工程师与架构师的标志！