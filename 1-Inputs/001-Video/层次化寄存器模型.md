---
Project:
  - UVM
description:
tags:
  - UVM
created: 2025-08-11 | 15:11
parent: Resource
---
# 001-Video
“在现实应用中,一般会将 uvm_reg_block再加入一个uvm_reg_block中,然后在base_test中实例化后者”

- 一般的,只会在第一级的uvm_reg_block中加入寄存器
- 第二级的uvm_reg_block通常只添加uvm_reg_block。
- 这样从整体上 呈现出一个比较清晰的结构。假如一个DUT分了三个子模块:用于控制全局的global模块、用于缓存数据的buf模块、用于接收发 送以太网帧的mac模块。global模块寄存器的地址为0x0000~0x0FFF,buf部分的寄存器地址为0x1000~0x1FFF,mac部分的寄存器 地址为0x2000~0x2FFF,那么可以按照如下方式定义寄存器模型”

要将一个子reg_block加入父reg_block中,第一步是先实例化子reg_block。第二步是调用子reg_block的configure函数。如果需要  使用后门访问,则在这个函数中要说明子reg_block的路径,这个路径不是绝对路径,而是相对于父reg_block来说的路径(简单起

见,上述代码中的路径参数设置为空字符串,不能发起后门访问操作)。第三步是调用子reg_block的build函数。第四步是调用子  reg_block的lock_model函数。第五步则是将子reg_block的default_map以子map的形式加入父reg_block的default_map中。这是可以理  解的,因为一般在子reg_block中定义寄存器时,给定的都是寄存器的偏移地址,其实际物理地址还要再加上一个基地址。寄存器  前门访问的读写操作最终都要通过default_map来完成。很显然,子reg_block的default_map并不知道寄存器的基地址,它只知道寄  存器的偏移地址,只有将其加入父reg_block的default_map,并在加入的同时告知子map的偏移地址,这样父reg_block的default_map  就可以完成前门访问操作了