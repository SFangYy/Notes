---
Project: ["XSPdb"]
Status: Ongoing
---
# Picker Pack 目录结构与功能优化方案

  

## 0. 背景与实施指南 (Context & Implementation Guide)

  

### 0.1 当前现状 (Current Implementation Status)

当前 `picker pack` 命令生成的目录结构较为扁平或存在多层嵌套，导致**可复用的组件代码**（Python/SV 封装）与**一次性的使用示例**（测试脚本）混杂在一起。

- **单事务模式**: 生成文件如 `DUT.py`, `Agent.sv`, `example.py`, `Makefile` 全部混在同一个目录下，或者生成如 `pack_example/adder_trans/DUTadder_trans/` 这样深层的嵌套结构。

- **多事务模式**: 虽然支持解析多个文件，但输出结构依然存在上述混淆问题，用户难以区分哪些是库文件，哪些是测试文件。

- **构建产物**: 编译产生的 `.so` 文件和 `csrc` 目录直接散落在源码目录中，造成污染。

  

### 0.2 实施目标 (Implementation Goals)

本次优化的核心目标是**严格分离**“可复用组件”（用户 `import` 的 Python 包）与“使用示例”（用户 `run` 的脚本）。

- **组件包 (Package)**: 包含 `__init__.py`, `DUT.py`, `Agent.sv`。应当是纯净的、可被直接导入的 Python 包。

- **使用示例 (Example)**: 包含 `example_dut.py`, `Makefile`。应当位于生成目录的根部，清晰地引用上述组件包。

  

### 0.3 需修改文件清单 (Files to Modify)

为实现上述目标，需修改 `picker` 代码库中的以下文件：

  

1. **`src/codegen/uvm.cpp`**:

* **逻辑变更**: 更新 `gen_uvm_param` 和 `gen_uvm_multi_param` 函数。

* **具体动作**: 修改目录创建逻辑，创建一个**项目根目录**以及在其下的 `<name>_pkg` **组件子目录**。

* **具体动作**: 将组件文件（`_xagent.sv`, `DUT.py` 等）生成路径重定向到 `_pkg` 目录。

* **具体动作**: 将示例文件（`example_dut.py`, `Makefile`）生成路径重定向到项目根目录。

  

2. **`template/uvm/Makefile`**:

* **逻辑变更**: 更新构建路径以指向 `_pkg` 子目录。

* **具体动作**: 修改 `BUILD_DIR` 和源文件路径，使其引用 `_pkg` 目录下的代码。

* **具体动作**: 更新 `run` 目标，确保 `LD_PRELOAD` 正确指向 `_pkg/build/` 下的共享库。

  

3. **`template/uvm/xdut.py`**:

* **逻辑变更**: 修正内部导入路径。

* **具体动作**: 确保如 `from . import xspcomm` 等相对导入在新的包结构下依然有效。

  

4. **`example/Pack/release-pack.sh`** (及相关测试脚本):

* **逻辑变更**: 统一测试脚本。

* **具体动作**: 将分散的测试脚本合并为一个主控脚本，统一处理单事务/多事务、DUT/非DUT模式的测试。

  

---

  

## 1. 详细目录结构设计 (Detailed Directory Structure)

  

### 1.1 优化方案概览

  

#### 当前痛点

1. **组件与示例混杂**：导致用户难以区分核心库和测试代码。

2. **Import 路径不清晰**：使得模块化引用（如 `from my_pkg import MyDUT`）不如独立的包结构直观。

3. **构建产物污染**：构建产物散落在源码目录。

  

#### 优化目标

1. **结构分离**：核心组件代码放入独立的子目录（Python包），示例代码在根目录。

2. **清晰引用**：用户只需 `import <package_name>` 即可使用组件。

3. **统一构建**：所有构建过程在顶层 Makefile 控制，但产物隔离。

  

### 1.2 不同场景下的输出结构

  

**场景 A: 不使用 -d -e (默认模式)**

*命令*: `picker pack adder_trans.sv`

*期望结构*:

```text

adder_trans_pkg/

├── __init__.py

├── adder_trans.py

└── adder_trans_xagent.py

```

  

**场景 B: 使用 -d 不使用 -e (仅生成组件)**

*命令*: `picker pack adder_trans.sv -d`

*期望结构*:

```text

adder_trans_pkg/

├── __init__.py # 导出 DUT 类

├── adder_trans.py # DUT Python

├── adder_trans_xagent.py

└── adder_trans_xagent.sv

```

  

**场景 C: 非 DUT 模式 + 示例 (-e)**

*命令*: `picker pack adder_trans.sv -e`

*期望结构*:

```text

pack_output/

└── adder_trans/ # 项目根目录

├── adder_trans_pkg/ # [核心组件包]

│ ├── __init__.py

│ ├── adder_trans_xagent.py

│ ├── adder_trans_xagent.sv

│ └── build/ # [构建产物]

├── example_python.py # [示例] 使用脚本

├── example_uvm.sv # [示例] Testbench

└── Makefile # [构建脚本]

```

  

**场景 D: DUT 模式 + 示例 (`-d -e`)**

*命令*: `picker pack adder_trans.sv -d -e`

*期望结构*:

```text

pack_output/

└── adder_trans/ # 项目根目录

├── adder_trans_pkg/ # [核心组件包]

│ ├── __init__.py # 导出 DUT 类

│ ├── adder_trans.py # DUT Python 类

│ ├── adder_trans_xagent.py

│ ├── adder_trans_xagent.sv

│ └── build/ # [构建产物]

├── example_dut.py # [示例] 使用脚本

├── example_uvm_dut.sv # [示例] Testbench

└── Makefile # [构建脚本]

```

  

*Import 逻辑 (在 example_dut.py 中)*:

```python

import sys, os

sys.path.append(os.getcwd()) # 确保能找到当前目录下的包

from adder_trans_pkg import adder_trans # 清晰导入

  

dut = adder_trans()

```

  

**场景 E: 多事务 DUT 模式 (`-f filelist.txt -n ALU -d -e`)**

*命令*: `picker pack -f filelist.txt -n ALU -d -e`

*期望结构*:

```text

pack_output/

└── ALU/ # 项目根目录

├── ALU_pkg/ # [核心组件包] (以 -n 名称 + _pkg 后缀命名)

│ ├── __init__.py # 导出 DUTALU

│ ├── DUTALU.py

│ ├── alu_op_xagent.sv

│ ├── alu_result_xagent.sv

│ ├── ALU_xagent.py

│ └── build/

├── example_dut.py # [示例]

├── example_uvm_dut.sv # [示例]

└── Makefile

```

  

---

  

## 2. 脚本整合与优化方案

  

### 2.1 当前痛点

* `example/Pack` 下存在 `release-pack.sh`。

* `example/MultiTransAdder` 下存在 `run_test.sh`, `release-multi-pack.sh`。

* 脚本功能分散，临时目录不统一 (`pack_output` vs `pack_multi_alu`)。

  

### 2.2 优化目标

1. **统一入口**：所有 Pack 相关测试通过 `example/Pack/release-pack.sh` 运行。

2. **统一临时目录**：所有测试生成的临时文件统一放在 `pack_output/` 下，方便清理。

3. **清理冗余**：删除 `example/MultiTransAdder` 下的 shell 脚本。

  

### 2.3 整合后的 `release-pack.sh` 逻辑

脚本位置: `example/Pack/release-pack.sh`

支持参数: `dut | multi | recv | send | all`

  

```bash

#!/bin/bash

set -e

  

# 统一输出目录

PACK_OUT="pack_output"

mkdir -p $PACK_OUT

  

# 辅助函数：准备环境

prepare() {

TEST_DIR="$PACK_OUT/$1"

rm -rf "$TEST_DIR"

mkdir -p "$TEST_DIR"

cd "$TEST_DIR"

}

  

# 1. 测试单事务 DUT 模式

test_dut() {

echo "=== Testing Single Transaction DUT Mode ==="

prepare "dut_test"

# 复制源文件

cp ../../example/Pack/adder_trans.sv .

# 生成

../../build/bin/picker pack adder_trans.sv -d -e

# 编译与运行 (进入生成的包目录)

cd adder_trans

make clean comp copy_xspcomm run

}

  

# 2. 测试多事务模式 (Multi-Transaction)

test_multi() {

echo "=== Testing Multi-Transaction Mode ==="

prepare "multi_test"

# 复制源文件

cp ../../example/MultiTransAdder/{alu_op.sv,alu_result.sv,filelist.txt} .

# 生成 (-n ALU)

../../build/bin/picker pack -f filelist.txt -n ALU -d -e

# 覆盖默认示例 (使用 MultiTransAdder 下的专用测试)

cp ../../example/MultiTransAdder/test_alu.py ALU/example_dut.py

cp ../../example/MultiTransAdder/test_alu_uvm.sv ALU/example_uvm_dut.sv

# 编译与运行

cd ALU

make clean comp copy_xspcomm run

}

  

# 3. 测试接收模式 (UVM -> Python)

test_recv() {

echo "=== Testing Receive Mode ==="

prepare "recv_test"

cp ../../example/Pack/adder_trans.sv .

../../build/bin/picker pack adder_trans.sv -e # 非 DUT 模式

# 覆盖示例

cp ../../example/Pack/Python2UVM/example_python.py adder_trans/

cp ../../example/Pack/Python2UVM/example_uvm.sv adder_trans/example_uvm.sv

cd adder_trans

make clean comp copy_xspcomm

# 非 DUT 模式下 Makefile 可能没有 run 目标，需手动运行

cd build && LD_PRELOAD=./_tlm_pbsb.so python3 ../example_python.py

}

  

# 4. 测试发送模式 (Python -> UVM)

test_send() {

echo "=== Testing Send Mode ==="

prepare "send_test"

# ... 类似 test_recv，使用 example/Pack/UVM2Python 下的文件 ...

}

  

# 主控逻辑

case "${1:-dut}" in

dut) test_dut ;;

multi) test_multi ;;

recv) test_recv ;;

send) test_send ;;

all) test_dut && test_multi && test_recv && test_send ;;

*) echo "Usage: $0 {dut|multi|recv|send|all}"; exit 1 ;;

esac

```

  

### 2.4 `pack_example` 与 `MultiTransAdder` 文件夹清理

1. **pack_example**: 建议重命名为 `example/Pack/SingleTransAdder`，与 `MultiTransAdder` 对应，结构更清晰。

2. **MultiTransAdder**:

* 保留: `.sv` 文件, `filelist.txt`, `test_alu.py` (改名为 `example_dut.py` 以匹配默认生成), `test_alu_uvm.sv`。

* 删除: `run_test.sh`, `release-multi-pack.sh`, `Makefile.test` (功能已移交 `release-pack.sh` 和模板生成的 Makefile)。

  

1. 完成的是通信相关的功能，现在需要对生成产物进行优化，这一步还没有实现

2. 选项C: 并行推进所有模块

3. 直接在当前目录生成包目录

4. 直接全面升级，只保持命令行接口兼容

5. 你可以先单个测试，没问题后整体测试